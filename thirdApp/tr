// Custom JSON converter for Vector2
public class Vector2JsonConverter : JsonConverter<Vector2>
{
    public override Vector2 Read(ref Utf8JsonReader reader, Type typeInfo, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException("Expected StartObject");

        float x = 0, y = 0;

        while (reader.Read())
        {
            if (reader.TokenType == JsonTokenType.EndObject)
                return new Vector2(x, y);

            if (reader.TokenType == JsonTokenType.PropertyName)
            {
                string? propertyName = reader.GetString();
                reader.Read();

                switch (propertyName)
                {
                    case "X":
                        x = reader.GetSingle();
                        break;
                    case "Y":
                        y = reader.GetSingle();
                        break;
                }
            }
        }

        throw new JsonException("Could not deserialize Vector2");
    }

    public override void Write(Utf8JsonWriter writer, Vector2 value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteNumber("X", value.X);
        writer.WriteNumber("Y", value.Y);
        writer.WriteEndObject();
    }
}

// Enhanced PieceOfData with type tracking
public class PieceOfData
{
    public object? Data { get; set; }
    public string? DataType { get; set; }
}

// Custom JSON converter for PieceOfData with type preservation
public class PieceOfDataJsonConverter : JsonConverter<PieceOfData>
{
    public override PieceOfData Read(ref Utf8JsonReader reader, Type typeInfo, JsonSerializerOptions options)
    {
        var jsonDoc = JsonDocument.ParseValue(ref reader);
        var root = jsonDoc.RootElement;

        var pieceOfData = new PieceOfData();

        // Retrieve the stored type information
        if (root.TryGetProperty("DataType", out var dataTypeElement))
        {
            pieceOfData.DataType = dataTypeElement.GetString();

            // Deserialize based on the stored type
            if (root.TryGetProperty("Data", out var dataElement))
            {
                // Use the type information to deserialize
                Type actualType = Type.GetType(pieceOfData!.DataType!)!;

                if (actualType != null)
                {
                    pieceOfData.Data = JsonSerializer.Deserialize(
                        dataElement.GetRawText(),
                        actualType,
                        options
                    );
                }
            }
        }

        return pieceOfData;
    }

    public override void Write(Utf8JsonWriter writer, PieceOfData value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();

        // Store the full type name
        writer.WriteString("DataType", value.Data?.GetType().AssemblyQualifiedName);

        // Write the data with its actual type
        writer.WritePropertyName("Data");
        JsonSerializer.Serialize(
            writer,
            value.Data,
            value.Data?.GetType() ?? typeof(object),
            options
        );

        writer.WriteEndObject();
    }
}
public class Vector3JsonConverter : JsonConverter<Vector3>
{
    public override Vector3 Read(ref Utf8JsonReader reader, Type typeInfo, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException("Expected StartObject");

        float x = 0, y = 0, z = 0;

        while (reader.Read())
        {
            if (reader.TokenType == JsonTokenType.EndObject)
                return new Vector3(x, y, z);

            if (reader.TokenType == JsonTokenType.PropertyName)
            {
                string? propertyName = reader.GetString();
                reader.Read();

                switch (propertyName)
                {
                    case "X":
                        x = reader.GetSingle();
                        break;
                    case "Y":
                        y = reader.GetSingle();
                        break;
                    case "Z":
                        z = reader.GetSingle();
                        break;
                }
            }
        }

        throw new JsonException("Could not deserialize Vector3");
    }

    public override void Write(Utf8JsonWriter writer, Vector3 value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteNumber("X", value.X);
        writer.WriteNumber("Y", value.Y);
        writer.WriteNumber("Z", value.Z);
        writer.WriteEndObject();
    }
}

public class Testa
{
    public int Val { get; set; }
}
public class Programaaa
{
    public static void Mainaaa(string[] args)
    {
        // Configure JSON serializer options
        var options = new JsonSerializerOptions
        {
            WriteIndented = true
        };
        options.Converters.Add(new Vector2JsonConverter());
        options.Converters.Add(new Vector3JsonConverter());
        options.Converters.Add(new PieceOfDataJsonConverter());

        // Example with Vector2
        var pieceOfDataVector2 = new PieceOfData
        {
            Data = new Vector2(4, 5)
        };

        // Example with Vector3
        var pieceOfDataVector3 = new PieceOfData
        {
            Data = new Vector3(1, 2, 3)
        };
        var pieceOfDataVectorTesta = new PieceOfData
        {
            Data = new Testa() { Val = 3 }
        };


        // Serialize Vector2
        string jsonStringVector2 = JsonSerializer.Serialize(pieceOfDataVector2, options);
        Console.WriteLine("Serialized Vector2 JSON:");
        Console.WriteLine(jsonStringVector2);

        // Deserialize Vector2
        var deserializedPieceOfDataVector2 = JsonSerializer.Deserialize<PieceOfData>(jsonStringVector2, options)!;

        // Verify Vector2
        if (deserializedPieceOfDataVector2.Data is Vector2 vector2)
        {
            Console.WriteLine("\nDeserialized Vector2:");
            Console.WriteLine($"X: {vector2.X}, Y: {vector2.Y}");
            Console.WriteLine($"Original Type: {deserializedPieceOfDataVector2.DataType}");
        }

        // Serialize Vector3
        string jsonStringVector3 = JsonSerializer.Serialize(pieceOfDataVector3, options);
        Console.WriteLine("\nSerialized Vector3 JSON:");
        Console.WriteLine(jsonStringVector3);

        // Deserialize Vector3
        var deserializedPieceOfDataVector3 = JsonSerializer.Deserialize<PieceOfData>(jsonStringVector3, options)!;

        // Verify Vector3
        if (deserializedPieceOfDataVector3.Data is Vector3 vector3)
        {
            Console.WriteLine("\nDeserialized Vector3:");
            Console.WriteLine($"X: {vector3.X}, Y: {vector3.Y}, Z: {vector3.Z}");
            Console.WriteLine($"Original Type: {deserializedPieceOfDataVector3.DataType}");
        }




        string jsonStringVectorTesta = JsonSerializer.Serialize(pieceOfDataVectorTesta, options);
        Console.WriteLine("\nSerialized Testa JSON:");
        Console.WriteLine(jsonStringVectorTesta);

        // Deserialize Vector3
        var deserializedPieceOfDataVectorTesta = JsonSerializer.Deserialize<PieceOfData>(jsonStringVectorTesta, options)!;

        // Verify Vector3
        if (deserializedPieceOfDataVectorTesta.Data is Testa test)
        {
            Console.WriteLine("\nDeserialized Testa:");
            Console.WriteLine($"X: {test.Val}");
            Console.WriteLine($"Original Type: {deserializedPieceOfDataVectorTesta.DataType}");
        }

    }
}

[JsonPolymorphic(TypeDiscriminatorPropertyName = "$type")]
[JsonDerivedType(typeof(PacketCustomData), typeDiscriminator: "PacketCustomData")]
[JsonDerivedType(typeof(PacketDoubleData), typeDiscriminator: "PacketDoubleData")]
public class PacketBase
{

}
public class PacketCustomData : PacketBase
{
    //This can be MyCustomData, string, int, etc...
    [JsonConverter(typeof(ObjectToInferredTypesConverter))]
    public object Data { get; set; }
}



public class PacketDoubleData : PacketBase
{
    public object Data1 { get; set; }
    public object Data2 { get; set; }

}
public class MyCustomData
{
    public string Field1 { get; set; }
}

// Custom JSON converter to handle byte array serialization
public class ByteArrayConverter : JsonConverter<object>
{
    public override object Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                // Deserialize base64 encoded string to byte array
                return Convert.FromBase64String(reader.GetString());
            case JsonTokenType.StartObject:
                // For complex objects, use the default deserializer
                return JsonSerializer.Deserialize(ref reader, typeof(object), options);
            default:
                return null;
        }
    }

    public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
    {
        if (value is byte[] byteArray)
        {
            // Serialize byte array to base64 string
            writer.WriteStringValue(Convert.ToBase64String(byteArray));
        }
        else
        {
            // Use the default serializer for other types
            JsonSerializer.Serialize(writer, value, value?.GetType() ?? typeof(object), options);
        }
    }
}

// Custom JSON converter to handle object serialization
public class ObjectToInferredTypesConverterA : JsonConverter<object>
{
    public override object Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        // Deserialize based on the current JSON token type
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                // Check if the string is a base64 encoded byte array
                string stringValue = reader.GetString();
                try
                {
                    byte[] byteArray = Convert.FromBase64String(stringValue);
                    return byteArray;
                }
                catch
                {
                    return stringValue;
                }
            case JsonTokenType.Number:
                if (reader.TryGetInt32(out int intValue))
                    return intValue;
                return reader.GetDouble();
            case JsonTokenType.True:
            case JsonTokenType.False:
                return reader.GetBoolean();
            case JsonTokenType.StartObject:
                // For complex objects, use the default deserializer
                return JsonSerializer.Deserialize(ref reader, typeof(object), options);
            default:
                return null;
        }
    }

    public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
    {
        // Special handling for byte arrays
        if (value is byte[] byteArray)
        {
            writer.WriteStringValue(Convert.ToBase64String(byteArray));
            return;
        }

        // Use the default serializer for writing
        JsonSerializer.Serialize(writer, value, value?.GetType() ?? typeof(object), options);
    }
}

public class ByteArrayConverter2 : JsonConverter<byte[]>
{
    public override void Write(Utf8JsonWriter writer, byte[] value, JsonSerializerOptions options) =>
        JsonSerializer.Serialize(writer, value.AsEnumerable());

    public override byte[]? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) =>
        reader.TokenType switch
        {
            JsonTokenType.String => reader.GetBytesFromBase64(),
            JsonTokenType.StartArray => JsonSerializer.Deserialize<List<byte>>(ref reader)!.ToArray(),
            JsonTokenType.Null => null,
            _ => throw new JsonException(),
        };
}
public class Programe
{
    public static void Maine(string[] args)
    {
        PacketBase packetWithData = new PacketCustomData()
        {
            Data = new MyCustomData[]{
                new MyCustomData(){
                    Field1 = "aaaaa"
                }
            }
        };

        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNameCaseInsensitive = true,
            Converters = {
                new Vector3JsonConverter(),
            // new ByteArrayConverter()
            },

        };



        string jsonString = JsonSerializer.Serialize(packetWithData, options);

        //{"$type":"PacketCustomData","Data":{"Field1":"Hi"}}
        Console.WriteLine("Serialized JSON: " + jsonString);


        //Lets supose I already know the type of packet is PacketCustomData
        PacketCustomData deserializedPacket = JsonSerializer.Deserialize<PacketCustomData>(jsonString, options);

        //And I already know that the data it holds is CustomData.
        //Unhandled exception. System.InvalidCastException: Unable to cast object of type 'System.Text.Json.JsonElement' to type 'CustomData'.
        // Properly convert the Data to CustomData
        var myData = deserializedPacket.Data is JsonElement jsonElement
    ? JsonSerializer.Deserialize<MyCustomData[]>(jsonElement, options)
    : (MyCustomData[])deserializedPacket.Data;


        //In this case, Field1 has "Hi"
        Console.WriteLine("Field1 data: " + myData[0].Field1);


    }
}

    static void aa<T>()
    {
        Console.WriteLine("typeof: " + typeof(T));
        var type = Type.GetType(typeof(T).FullName);
        Console.WriteLine(type.Name);
        byte[] arr = new byte[19];
        aa<byte[]>();

        var typeStr = arr.GetType().FullName;
        Console.WriteLine(typeStr);

        Console.WriteLine(Type.GetType(typeStr).Name);

    }
